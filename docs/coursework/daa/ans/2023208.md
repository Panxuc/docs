# 缺失数据恢复

我对本题持一种复杂的态度，因为我认为，它所考察的并不是算法的优劣，而是解答者实现的代码与命题人的算法的异同。

这道题需要用到多项式拟合，这本身没有什么好说的。数据与算法课堂上讲了几种插值法，包括拉格朗日插值法、牛顿插值法等。我综合使用了牛顿插值法和切比雪夫插值法，在经过很长时间的我认为对于算法没有什么实质性帮助的调参之后，最终通过了这道题的全部 10 个测试点。

实际测试下来，牛顿插值法对于低阶多项式拟合计算更简便，而经过改良的切比雪夫插值法对于高阶多项式更精确、可靠。这可能与我具体实现方法有关。不过事实上，切比雪夫插值法也是能够避免牛顿插值法的龙格问题的，虽然这跟这道题没有什么关系。

在调参过程中，我一开始不断降低一个阈值，力求使答案更加精确，但是发现这并不能通过测试点，反而越精确，有的点越不过。在一次巧合中，我发现，如果我反向调阈值，使答案变得不精确一点，它反而通过了更多的测试点！根据我粗浅的观察，我认为在这些测试点中，由于判题程序或者本题给出的答案本身的精度问题，使得我的答案在精确到一定程度之后，反而不通过测试点。这是一种非常不好的现象，因为这意味着，我必须要在精度和正确性之间做出取舍，而这种取舍是不可预测的，因为我不知道 OJ 的判题程序是如何实现的，也不知道本题给出的答案是如何计算的。

我认为，如果真的要考察学生对插值法的掌握程度，就不应该在误差小于 $1e-6$ 上死磕，而是应该将允许的误差放大一点。毕竟，出题人又如何保证自己拟合的就是绝对精确的呢？

在所有测试点中，只有 6、8、10 三个测试点 $n>20$，只有 6 一个测试点 $n>30$。

| #   | 状态     | 时间   | 内存    |
| --- | -------- | ------ | ------- |
| 1   | Accepted | 0 ms   | 788 KB  |
| 2   | Accepted | 0 ms   | 768 KB  |
| 3   | Accepted | 0 ms   | 760 KB  |
| 4   | Accepted | 0 ms   | 768 KB  |
| 5   | Accepted | 0 ms   | 772 KB  |
| 6   | Accepted | 0 ms   | 1000 KB |
| 7   | Accepted | 4 ms   | 788 KB  |
| 8   | Accepted | 40 ms  | 896 KB  |
| 9   | Accepted | 940 ms | 772 KB  |
| 10  | Accepted | 872 ms | 888 KB  |
