# 缺损二叉树

本题虽然看起来很复杂，但是，如果上课认真听讲的话，就能很快做出来。

本题的提示很关键。请看这句话：

> 对本题，可以根据题目要求逐行构造该缺损二叉树。对于当前行，记录所有非缺损点，在下一行依次构造子节点，并排除缺损点，直到构造到目标节点为止。利用构造节点时记录的父亲节点编号，可以从目标节点搜索到回到根节点的路径，将该路径翻转，即可得到所求路径。

我们可以思考一下这棵缺损二叉树的大小。由于题目假定缺损点及目标点数目不超过 $100$ 个，目标节点编号均小于 $2^{32}$。因此，通过简单的数学运算，我们可以知道，这棵缺损二叉树不会超过 $132$ 层。这对于限时 1000ms 的本题来说是一个很大的突破点。我们可以对于每一个目标点，都只构建它所在的那条路径，这样事实上并不会消耗许多时间。

二叉树是一个非常美观的数据结构。它有很强的数学性质。我们以完全二叉树为例。假设我们的二叉树的根节点的编号为 $1$，那么，对于任意一个节点 $i$，它的左儿子的编号为 $2i$，它的右儿子的编号为 $2i+1$。这样，假如我们想要从子节点出发，找到它的父节点，那么，我们只需要将它的编号除以 $2$，就可以得到它的父节点的编号。这样，我们就可以从目标节点出发，一直向上找，直到找到根节点为止。这样，我们就可以得到从目标节点到根节点的路径。

这个性质对于缺损二叉树是相通的。下面请看详细说明。

![缺损二叉树](http://oj.ee.tsinghua.edu.cn/media/ckeditor_uploads/2023/11/03/4.png)

我们用例题举例。我们想找到 $15$ 的父节点。于是我们将 $15$ 除以 $2$，得到 $7$。我们发现， $5$ 是一个缺损点， $7$ 不可避免地会受到影响。我们将 $7$ 加一，得到 $8$。继续来看，我们发现 $6$ 也是一个缺损点。 $8$ 再自增 $1$，得到 $9$。我们发现 $9$ 也是一个缺损点。我们再自增 $1$，得到 $10$。我们发现 $10$ 不是一个缺损点。所以， $10$ 就是 $15$ 的父节点。

接下来，我们只要考虑一些特殊情况就可以了。如果一整行都是缺损点会怎样？如果 $1$ 是目标点会怎样？……

另外，注意目标节点编号均小于 $2^{32}$，这是一个很大的数。因此，我们需要用 `unsigned int` 来存储它们。

```cpp
#include <cstdio>

int main()
{
    int N = 0, M = 0;
    scanf("%d%d", &N, &M);
    unsigned int colo[N] = {0};
    unsigned int dest[M] = {0};
    for (int i = 0; i < N; i++)
    {
        scanf("%d", &colo[i]);
    }
    for (int i = 0; i < M; i++)
    {
        scanf("%d", &dest[i]);
    }
    unsigned int path[200] = {0};
    for (int i = 0; i < M; i++)
    {
        if (dest[i] == 1)
        {
            printf("1\n");
        }
        else
        {
            path[0] = dest[i];
            bool noPath = false;
            unsigned int temp = 0;
            int lastJ = 0;
            for (int j = 1; j < 132; j++)
            {
                temp = path[j - 1] / 2;
                for (int k = 0; k < N; k++)
                {
                    if (colo[k] <= temp)
                    {
                        temp++;
                    }
                    else
                    {
                        break;
                    }
                    if (temp >= path[j - 1])
                    {
                        break;
                    }
                }
                if (temp >= path[j - 1])
                {
                    noPath = true;
                    break;
                }
                else
                {
                    path[j] = temp;
                    if (temp == 1)
                    {
                        lastJ = j;
                        break;
                    }
                }
            }
            if (noPath)
            {
                printf("0\n");
            }
            else
            {
                for (int j = lastJ; j >= 0; j--)
                {
                    printf(j == 0 ? "%u\n" : "%u ", path[j]);
                }
            }
        }
    }
    return 0;
}
```

| #   | 状态     | 时间 | 内存   |
| --- | -------- | ---- | ------ |
| 1   | Accepted | 0 ms | 768 KB |
| 2   | Accepted | 0 ms | 764 KB |
| 3   | Accepted | 0 ms | 760 KB |
| 4   | Accepted | 0 ms | 772 KB |
| 5   | Accepted | 0 ms | 788 KB |
| 6   | Accepted | 0 ms | 760 KB |
| 7   | Accepted | 0 ms | 756 KB |
| 8   | Accepted | 0 ms | 788 KB |
| 9   | Accepted | 0 ms | 756 KB |
| 10  | Accepted | 0 ms | 784 KB |
